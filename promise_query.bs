<pre class='metadata'>
Title: Executors are full of promise
Shortname: PTODO
URL: wg21.link/PTODO
Revision: 0
Audience: SG1
Status: D
Group: WG21
!Source: <a href="https://github.com/executors/futures/blob/master/promise_query.bs">github.com/executors/futures/blob/master/promise_query.bs</a>
No Abstract: yes
Markup Shorthands: markdown yes
Markup Shorthands: biblio yes
Editor: Lee Howes, Facebook, lwh@fb.com
Editor: Christopher Kohlhoff, chris@kohlhoff.com
</pre>

TLDR {#tldr}
=====================

`ThenExecutors` are currently insufficient. To make them useful we need a mechanism to get handle to trigger work after it has been enqueued into the executor.

Introduction {#intro}
=====================

[p0443](https://wg21.link/P0443) defines a collection of executor types intended for use managing the execution of tasks on resources.
There are three fundamental executor categories that cover directionality and control of launch:
 * one-way
 * two-way
 * then

The first two could be considered *immediately launched*. That is that once handed to the executor,
they may start immediately, assuming the internal executor policies and resources allow it. This makes them
very useful for lazy-launch scenarios.

Lazy launch scenarios are common in callback-based code, and in a wide range of future library implementations such as [folly](https://github.com/facebook/folly/tree/master/folly/futures).
In these designs, a callback is executed on completion of some asynchronous work, and that callback enqueues work into the executor.
This means that work is enqueued only after all dependencies are satisfied.

Then-executors, on the other hand, are intended for explicitly deferred work. Work can be handed to the executor dependent on prior work, before that prior work is completed.
This design is fundamentally different, but offers scope for optimisation by the executor of chains of dependencies that is can batch, without running additional code on completion of each.

The current executor design is intentionally generic - it makes few requirements on the future types it can use as input dependencies for the `then_execute` and `bulk_then_execute` operations.
We can assume that for a future returned by a previous call to `then_execute` or `bulk_then_execute`, the executor understands the implementation of the future can can perform whatever depenence tracking and optimisation necessary.
This then is an implementation detail.

However, there will also be interactions where a task to run on one executor is dependent on one produced by another. For this to be practical, we need a standardised mechanism to tie the two executors together.
This amounts to a standard API for triggering deferred work.

Why starting with a two-way execute is not enough
====================

One easy assumption to make is that we can achieve this by starting with a call to `two-way execute` on the executor, and then following up with a `then_execute` operation.
In simplified terms, assuming the executor is capable of both two-way- and then-execution:
```
AnExecutor e;
auto f = e.twoway_execute([](){return 3;});
auto f2 = e.then_execute([](int a){return a + 1;}, std::move(f));
auto r = std::this_thread::get(f2);
assert(r==3);
```

In a simple example like this, this is correct. However, imagine putting this in a future chain, based loosely on the future design proposed in [PTODO](wg21.link/PTODO):
```
AnExecutor e;
AnOtherExecutor e2;
auto f =
  async_function_that_returns_a_future_of_value_2()
  .via(e)                        // Change to executor e
  .then([](int a){return a+1;})  // task 1
  .via(e2)                       // Change to executor e2
  .then([](int a){return a+1;}); // task 2
auto r = std::this_thread::get(f2);
assert(r==3);
```

We cannot enqueue task 1 until the initial future completes, returning 2.
If we cannot do that, we have no intermediate future returned by twoway_execute to continue this chain,
and so we simply have no future as an input dependency to then_execute.

Somehow then we have to add a work trigger, such that the full chain of pending futures can be built in advance, but the chain is not triggered until some event happens.
In a long chain across multiple executors there will be multiple such interaction points.

Proposed solution
====================



Proposed New Wording
====================
